# Explorative Datenanalyse

```{r setup-chapter-4}
#| include: false
library(mosaic)
library(latex2exp)
library(gridExtra)

# Aufgabenverwaltung initialisieren
ch <- 5
quiz <- 0
```

```{r child="FarbSchema.qmd"}
```

```{r child="gg-margins.qmd"}
```

::: {.callout-tip .Lernergebnisse}
## Lernergebnisse dieses Kapitels

Nach erfolgreichem Abschluss dieses Kapitels sind Sie in der Lage,

-   Daten in RStudio zu importieren, insbesondere über das CSV Format;

-   zentrale Statistiken und Grafiken für kategoriale und metrische Variablen zu nutzen und zu interpretieren;

-   Verteilungsformen numerischer Daten unterscheiden zu können;

-   eine empirische Verteilungsfunktion interpretieren zu können;

-   den Zusammenhang zwischen Variablen darstellen und beschreiben zu können
:::

Wir beginnen mit dem Einlesen von Daten. Dazu wird der Beispielsdatensatz `tips.csv` [^kapitel-5-1] eingelesen. Dieser liegt im sogenannten CSV-Format (*comma separated values*) vor. Dieses Format ist sehr nützlich, um Daten auszutauschen, da es ein reines Textformat ist und auf allen Rechnern und Betriebssystemen gelesen werden kann. Wenn Sie `tips.csv` mit einem Texteditor öffnen, sieht die Datei so aus:

[^kapitel-5-1]: Bryant u. a. (1995), Practical Data Analysis -- Case Studies in Business Statistics

```         
"total_bill";"tip";"sex";"smoker";"day";"time";"size"
16,99;1,01;"Female";"No";"Sun";"Dinner";2
10,34;1,66;"Male";"No";"Sun";"Dinner";3
21,01;3,5;"Male";"No";"Sun";"Dinner";3
23,68;3,31;"Male";"No";"Sun";"Dinner";2
24,59;3,61;"Female";"No";"Sun";"Dinner";4
25,29;4,71;"Male";"No";"Sun";"Dinner";4
...
```

In der ersten Zeile stehen die Namen der Variablen, danach kommen die einzelnen Beobachtungen. Die Werte sind mit Semikola getrennt, das Dezimaltrennzeichen ist das Komma. Zeichenketten stehen in doppelten Anführungszeichen.

::: {.callout-tip .Tipp}
## Tipp

Variablennahmen sollten mit Buchstaben beginnen und keine Leeroder Sonderzeichen enthalten und auch Umlaute sollten vermieden werden.
:::

Die Datei kann mit `read.csv2()` eingelesen werden, diese Funktion liest ein sogenanntes deutsches CSV ein. In amerikanischen CSV-Dateien ist das Datentrennzeichen ein Komma (daher *comma separated values*) und das Dezimaltrennzeichen ein Punkt.

Der ganze Befehl sieht dann so aus:

```{r}
#| echo: true
tips <- read.csv2("data/tips.csv")
```

Ob `data/` vor dem Dateinamen steht, hängt davon ab, ob Sie die Datei in einem Unterverzeichnis gespeichert haben (z. B. bei Verwendung der Projektdatei --- siehe Kapitel 2 R und RMarkdown).

::: {.callout-tip .Hinweis}
## Hinweis

Im Code oben ist `<-` der sogenannten Zuweisungspfeil. Das, wo der Pfeil herkommt (hier: was rechts davon steht), wird in dem Objekt abspeichert, wo der Pfeil hinzeigt (hier links davon).
:::

CSV-Dateien können aus Tabellenkalkulationsprogrammen abgespeichert werden. R kann aber auch viele andere Datenformate lesen.

::: {.callout-note .Aufgabe}
## Aufgabe `r quiz <- quiz + 1; paste0(ch, ".", quiz)`

Öffnen Sie die Datei `tips.csv` in Excel (oder einem anderen Tabellenkalkulationsprogramm).
:::

::: {.callout-tip .Tipp}
## Tipp

Die Lösung (oder Erläuterung) finden Sie am Ende dieses Kapitels. -- Versuchen Sie stets, eine Aufgabe zunächst selbst zu lösen, bevor Sie nachschlagen. Die aktive Auseinandersetzung ist Ihr Schlüssel zum Lernerfolg!
:::

Um erste Informationen zu dem Datensatz zu erhalten, können Sie den Befehl `str(tips)` verwenden.

```{r}
str(tips)
```

Eine Datentabelle (`data.frame`) kann aus mehreren Variablen (Spalten) mit gleicher Anzahl Beobachtungen (Zeilen) bestehen. Die Variablennamen finden Sie in der Spalte nach dem \$-Zeichen, dahinter steht der Variablentyp, gefolgt von den ersten Daten.

::: {.callout-note .Aufgabe}
## Aufgabe `r quiz <- quiz + 1; paste0(ch, ".", quiz)`

Was unterscheidet die Variablentypen `int` und `num`?
:::

@tbl-variablentypen

| Typ    | Verwendung                                                       |
|:----------------|:------------------------------------------------------|
| chr    | *character*, Zeichenkette                                        |
| factor | Faktor (Zeichenkette mit wenigen unterschiedlichen Ausprägungen) |
| int    | *integer*, ganzzahlig                                            |
| num    | *numeric*, Gleitkommazahlen                                      |

: Variabltypen in R {#tbl-variablentypen}

Für diesen Datensatz sammelte ein Keller über mehrere Monate sein Trinkgeld. @tbl-tipsdata zeigt die darin abgespeichertern Variablen.

| Name         | Bedeutung                         |
|:-------------|:----------------------------------|
| `total_bill` | Rechnungshöhe in Dollar           |
| `tip`        | Trinkgeld in Dollar               |
| `sex`        | Geschlecht des Rechnungszahlenden |
| `smoker`     | Gab es Raucher:innen am Tisch?    |
| `day`        | Wochentag                         |
| `time`       | Tageszeit                         |
| `size`       | Anzahl Personen am Tisch          |

: Variablen des Datensatzes `tips.csv` {#tbl-tipsdata}

::: {.callout-note .Aufgabe}
## Aufgabe `r quiz <- quiz + 1; paste0(ch, ".", quiz)`

Welches Skalenniveau haben die Variablen im Datensatz `tips.csv`?
:::

## Analyse kategorialer Daten

Im ersten Schritt beschäftigen wir mit der Analyse kategorialer Daten. Wir werden verschiedene Grafiken wie Säulendiagramm, Balkendiagramm oder Mosaikplot kennenlernen. Kreis- oder Kuchendiagramme werden wir allerdings nicht anschauen. Die Häufigkeiten der verschiedenen Kategorien können absolut oder relativ (als Anteile oder Prozente) angegeben werden.

::: {.callout-note .Aufgabe}
## Aufgabe `r quiz <- quiz + 1; paste0(ch, ".", quiz)`

Warum werden Kreisdiagramme insbesondere in der Wissenschaft nicht gerne gesehen?
:::

### Häufigkeiten und Anteile {.unnumbered .unlisted}

Säulendiagrammewerden mit `gf_bar( ~ my.x, data = my.data)` ausgeführt, `my.x` ist die Variable, die dargestellt werden soll (z. B. `day`), `my.data` die Datentabelle, die verwendet werden soll (z. B. `tips`).

::: {.callout-tip .Tipp}
## Tipp

Zur Erinnerung: Die Tilde \~ wird auf Windows-Rechnern mit der Tastenkombination {{< kbd AltGr-+}} ausgewählt, auf Mac-Rechnern mit {{< kbd Option-n >}}.
:::

Wenn wir also die Häufigkeiten der Wochentage grafisch darstellen wollen, sieht der vollständige Befehl also so aus:

```{r}
#| label: fig-bar-tips
#| fig-cap: "Säulendiagramm der Variable `day` in der Datentabelle `tips`"

gf_bar( ~ day, data = tips)
```

Sie erkennen in @fig-bar-tips, dass am Samstag (`Sat`) die meisten Belege erfasst wurden, gefolgt von Sonntag (`Sun`) und Donnerstag (`Thur`). Freitag (`Fri`) liegt abgeschlagen auf dem letzten Platz.

::: {.callout-tip .Hinweis}
## Hinweis

Vielleicht haben Sie es schon gemacht. Bevor `gf_bar()` ausgeführt werden kann, muss das Paket `mosaic` mit dem Befehl `library(mosaic)` geladen werden.
:::

::: {.callout-note .Aufgabe}
## Aufgabe `r quiz <- quiz + 1; paste0(ch, ".", quiz)`

Warum ist die Reihenfolge der Wochentage so *komisch*?
:::

Kategoriale Variable werden in R entweder als Zeichenkette (Variablentyp `chr`) oder (früher) als *sogenannter* Faktor abgespeichert (Variablentyp `factor`). Bei Zeichenketten werden die Kategorien alphanumerisch aufsteigend sortiert. Wenn die Reihenfolge geändert werden soll, muss die Variable als Faktor gespeichert werden. Wenn Sie die Häufigkeiten (englisch: *count*, Symbol $h_i$) aller Kategorien $i$ erhalten wollen, können Sie den Befehl `tally()` verwenden.

::: {.callout-note .Aufgabe}
## Aufgabe `r quiz <- quiz + 1; paste0(ch, ".", quiz)`

`tally` kommt aus dem Englischen. Was ist eine passende Übersetzung dafür?
:::

```{r}
tally( ~ day, data = tips)
```

::: {.callout-tip .Tipp}
## Tipp

Sie sehen, der Aufbau der Befehle, insbesondere bei Verwendung des Pakets `mosaic`, ist immer gleich: `~ Variable` -- Variable, die analysiert werden soll, `data = tips` -- Datentabelle, die verwendet werden soll.
:::

Um Anteile (englisch: *proportion*) darzustellen, können Sie die Option `format = "proportion"` ergänzen, für Prozentwerte entsprechend `format = "percent"`.

```{r}
tally( ~ day, data = tips, format = "prop")
```

::: {.callout-tip .Tipp}
## Tipp

Bei den meinsten Optionswerten, die als Zeichenkette in Anführungzeichen eingegen werden, reicht es, weniger Buchstaben anzugeben, hier z. B. "prop" oder "per". Es muss nur eindeutig sein.
:::

::: {.callout-tip .Tipp}
## Tipp

An welcher Stelle die Option ergänzt wird, ist egal. Sie können also auch `tally( ~ day, format = "prop", data = tips)` schreiben. Die einzelnen Abschnitte eines Funktionsaufrufs werden mit Kommata getrennt.
:::

Manchmal ist es notwendig, nur einen Wert auszugeben. Dazu können Sie die Funktion `prop()` verwenden.

```{r}
prop( ~ day, data = tips)
```

::: {.callout-note .Aufgabe}
## Aufgabe `r quiz <- quiz + 1; paste0(ch, ".", quiz)`

Kategorien bei `prop()`

a)  Welche Kategorie wird angezeigt?
b)  Warum?
c)  Wie können Sie andere Kategorien anzeigen lassen?

Sie können das mit `?mosaic::prop` herausfinden.
:::

::: {.callout-tip .Tipp}
## Tipp

Das Fragezeichen zeigt die Hilfe zu einem Befehl an. Da diese Sequenz nicht in das R-Skript aufgenommen werden soll, geben Sie diese am besten in der Konsole (das eigentlich R-Fenster) ein. Normalerweise finden Sie die Konsole in RStudio im Fenster unten links.
:::

::: {.callout-tip .Tipp}
## Tipp

`mosaic::` muss nicht unbedingt davor angegeben werden, aber so wird sichergestellt, dass nach der Hilfe für die Funktion aus dem Paket `mosaic` gesucht wird. Wenn Sie nicht wissen, ob die Funktion aus einem nachträglich geladenen Paket stammt, lassen Sie diesen Teil einfach weg.
:::

::: {.callout-note .Aufgabe}
## Aufgabe `r quiz <- quiz + 1; paste0(ch, ".", quiz)`

Stellen Sie Verteilung der Tageszeit (Variable `time`) als Säulendiagramm und als (relative) Häufigkeitstabelle dar.
:::

### Zusammenhang zwischen kategorialen Variablen {.unnumbered .unlisted}

Die Tageszeit variiert. Mit welchen Variablen hängt das zusammen? Sie können die Analysen, die wir bisher gemacht haben, auch nach einer weiteren Variable gruppieren (bedingen). Dazu wird die Formel mit einem senkrechten Strich \| ergänzt.

::: {.callout-tip .Tipp}
## Tipp

Außer der Tilde \~ gibt es in den Formeln noch den Strich \|, der die Grafik (oder andere Funktionen) in mehrere Gruppen aufteilt. Auch hier gibt es ein Tastenkürzel: Windows {{< kbd AltGr-< >}}, Mac {{< kbd Option-7 >}}. Das sind jetzt aber auch schon alle (zumindest für die Formelsyntax).
:::

Im Falle von `time` könnte beispielsweise ein Zusammenhang mit dem Tag vorliegen:

```{r}
#| fig-cap: "Säulendiagramm von `time` gruppiert nach `day`"
#| fig-width: 5
#| fig-asp: 1
#| label: fig-rpTimeDay
#| out-width: 10cm
gf_bar( ~ time | day, data = tips)
```

Wie Sie sehen können, sind die Verteilungen der Tageszeit an den Tagen unterschiedlich. Am Samstag und Sonntag scheint es gar keine Besuche zur Mittagszeit gegeben zu haben (vielleicht hatte das Restaurant nur abends auf?), während es am Donnerstag fast nur Besuche zur Mittagszeit gab.

Das gruppierte Verteilung können wir auch mit `tally()` darstellen, eine sogenannte Kreuztabelle:

```{r}
# absolut
tally( ~ time | day, data = tips)

# oder relativ als Anteil
tally( ~ time | day, data = tips, format = "prop")
```

Alternativ können Sie bei `tally()` auch folgenden Aufruf verwenden:

```{r}
tally(time ~ day, data = tips)
```

Das ist die Variante $\text{\textit{Abhängige Variable}} \sim \text{\textit{Unabhängige Variable}}$, bzw. $AV \sim UV$ oder $y \sim x$.

::: {.callout-note .Aufgabe}
## Aufgabe `r quiz <- quiz + 1; paste0(ch, ".", quiz)`

Geht diese Variante auch bei `gf_bar()`? Probieren Sie es aus. Wenn nein, warum nicht?
:::

Wir haben jetzt die Grundstruktur (die Formelsyntax) der Befehle gelernt, die mit Hilfe des Pakets `mosaic` in R durchgeführt werden können:

$AV \sim UV \mid GV$ -- abhängige Variable in Abhängigkeit von der unabhängigen Variablen ggf. gruppiert nach einer Gruppierungsvariable.

::: {.callout-note .Aufgabe}
## Aufgabe `r quiz <- quiz + 1; paste0(ch, ".", quiz)`

Führen Sie eine Kreuztabellierung der Anteile der Raucher je Wochentag durch. Ist es egal, welche Variable die abhängige bzw. die unabhängige ist? Vergleichen Sie absolute und relative Häufigkeiten -- *richtigherum* und *falschherum*.
:::

Bei relativen Häufigkeiten müssen Sie darauf achten, wovon der relative Anteil ausgegeben wird: *Confusion of the inverse*:

-   Der Anteil der Raucher am Freitag entspricht nicht dem Anteil des Freitags der Raucher.

-   Der Papst ist ein Mann, aber nur die allerwenigsten Männer sind Papst.

-   Die Wahrscheinlichkeit, krank zu sein, wenn das Testergebnis positiv ist, ist nicht dasselbe wie die Wahrscheinlichkeit, dass das Testergebnis positiv ist, wenn man krank ist.

### Bedingte und totale Wahrscheinlichkeit {.unnumbered .unlisted}

Die relative Häufigkeit der Uhrzeit (Ereignis $A$) gegeben den Wochentag (Ereignis $B$) können Sie auch als bedingte Wahrscheinlichkeit interpretieren, z. B. `Pr(time = Lunch|day = Thur)`:

$$
Pr(A \mid B)
$$

Das wäre in unserer Kreuztabelle `tally( ~ time | day, ...)` der zweite Wert aus der vierten Spalte: 0.983871.

```{r}
tally( ~ time | day, data = tips, format = "prop")
```

Einzelne Werte aus einem Vektor können Sie mit $[\#]$ auslesen, $\#$ gibt die Position im Vektor an. Bei einer Matrix wie oben benötigen Sie die Zeilen- und die Spaltennummer: $[\#, \#]$, getrennt durch ein Komma.

::: {.callout-note .Aufgabe}
## Aufgabe `r quiz <- quiz + 1; paste0(ch, ".", quiz)`

Bestimmen Sie den Wert für $Pr(time = Lunch \mid day = Thur)$ mit `tally()`. Statt zwei Zahlen für die Zeile und die Spalte anzugeben, können Sie auch die Bezeichnungen, hier "`Lunch`" und "`Thur`" angeben.
:::

::: {.callout-tip .Tipp}
## Tipp

Die eckigen Klammern bekommen Sie auf Windows-Rechnern mit {{< kbd AltGr-8 >}} und auf Mac-Rechnern mit {{< kbd Option-5 >}}.
:::

Um die totale Wahrscheinlichkeit für die Uhrzeit "`Lunch`" zu bestimmen, können Sie die einzelnen bedingten Wahrscheinlichkeiten multipliziert mit den jeweiligen Wahrscheinlichkeiten (Ereignisse $B_k, k=1, \dots,K$\[\^Formal müssen die Ereignisse $B_k$ überschneidungsfrei sein und die Wahrscheinlichkeiten in der Summe eins ergeben.\], welche die Bedingungen stellen, auf addieren:

$$
\begin{aligned}
Pr(A) &= Pr(A \mid B_1) \cdot Pr(B_1) + Pr(A \mid B_2) \cdot Pr(B_2) +  \cdots \\
      &= Pr(A \mid B_K) \cdot Pr(B_K)
\end{aligned}
$$

hier also:

$$
\begin{aligned}
Pr(time = Lunch) =&Pr(time = Lunch \mid day = Thur) · Pr(day = Thur) +\\ 
                  &Pr(time = Lunch \mid day = Fri) · Pr(day = Fri) + \\
                  &\dots
\end{aligned}
$$

```{r}
# Totale Wahrscheinlichkeit
( tally( ~ time | day, data = tips, format = "prop")["Lunch", ] *
tally( ~ day, data = tips, format = "prop") ) |> sum()

# Kontrolle
prop( ~ time, success = "Lunch", data = tips)
```

Ok, das sieht jetzt etwas kompliziert aus. Was haben wir gemacht: Die erste Zeile liest die bedingten Wahrscheinlichkeiten für "`Lunch`" für alle Wochentage aus. Die zweite Zeile gibt die Wahrscheinlichkeiten (bzw. Anteile) für die Wochentage zurück. Beide Zeilen wurden miteinander elementweise multipliziert und dann aufsummiert.

::: {.callout-tip .Hinweis}
## Hinweis

Die Multiplikation von Vektoren mit `*` in R geht elementweise vor, anders als in der Mathematik, da wird ein Zeilenvektor mit einem Spaltenvektor zu einem Skalarprodukt zusammengefasst. Das Skalarprodukt zweier Vektoren können Sie mit `%*%` berechnen, dann benötigen Sie kein `sum()` mehr. Probieren Sie es aus.
:::

::: {.callout-note .Aufgabe}
## Aufgabe `r quiz <- quiz + 1; paste0(ch, ".", quiz)`

Bedingte und totale Wahrscheinlichkeit:

a)  Wie hoch ist die Wahrscheinlichkeit für einen Rauchertisch beim Mittagessen?

b)  Bestimmen Sie die totale Wahrscheinlichkeit für einen Nichtrauchertisch aus dem Zusammenhang mit der Uhrzeit.
:::

Mit dem **Satz von Bayes** und der totalen Wahrscheinlichlichkeit können wir die bedingten Wahrscheinlichkeiten umrechnen:

$$
Pr(B \mid A) = \frac{Pr(A \mid B) \cdot Pr(B)}{Pr(A)}.
$$

::: {.callout-note .Aufgabe}
## Aufgabe `r quiz <- quiz + 1; paste0(ch, ".", quiz)`

Bestimmen Sie Wahrscheinlichkeit für Freitag bedingt Essenszeit Dinner über den Satz von Bayes. Kontrollieren Sie das Ergebnis mit `tally()`.
:::

Auf dem Satz von Bayes basiert eine eigene Richtung in der Statistik, die *Bayes-Statistik*. Wir bleiben hier aber in der sogenannten *frequentistischen Statistik*.

### Grafische Darstellung des Zusammenhangs {.unnumbered .unlisted}

Den Zusammenhang zwischen zwei kategorialen Variablen können Sie gut mit dem Mosaikplot darstellen: `mosaicplot(x ~ y, data = ...)`.

::: {.callout-tip .Hinweis}
## Hinweis

Im Aufruf von `mosaicplot()` sind die Variablen vertauscht: Die unabhängige Variable muss als erstes angegeben werden, die abhängige Variable als zweites.
:::

Hier der Mosaikplot zu Raucher je Wochentag:

```{r}
#| echo: true
#| eval: false
mosaicplot(day ~ smoker, data = tips)
```

```{r}
#| echo: false
#| label: fig-rpMosaic
#| eval: true
#| fig-cap: "Mosaikplot Raucher in Abhängigkeit vom Wochentag. $x$ und $y$ müssen im Aufruf von `mosaicplot()` vertauscht werden."
#| fig-width: 4.3
#| fig-asp: 1
#| out-width: 7cm
# out-extra: "trim=12mm 15mm 13mm 19mm, clip"
mosaicplot(day ~ smoker, data = tips, 
           main = NULL, 
           color = c(bgcolGray, bgcolFOMGreen))
```

::: {.callout-note .Aufgabe}
## Aufgabe `r quiz <- quiz + 1; paste0(ch, ".", quiz)`

Beschreiben Sie einen Mosaikplot! Was genau wird in Richtung der $x$-Achse, was in Richtung der $y$-Achse dargestellt? Was entspricht dem Flächenanteil einer Kachel? Stellen Sie alle diese Information mit `tally()` dar.
:::

Auch mit einem Säulendiagramm können Sie Zusammenhänge darstellen. Sie können die Farbe `(fill = ...)` nach einer anderen Variable auswählen, das ist dann die abhängige Variable.

```{r}
#| echo: true
#| eval: false
gf_bar( ~ day, fill = ~ smoker, data = tips)
gf_bar( ~ day, fill = ~ smoker, data = tips, position = position_dodge())
gf_bar( ~ day, fill = ~ smoker, data = tips, position = "fill")
```

```{r}
#| echo: false
#| eval: true
#| fig-align: center
#| fig-width: 5
#| fig-asp: 0.7
#| out-width: 10cm
#| fig-cap: "Säulendiagramm der Wochentage, farbig markiert sind die Anteile der Raucher und Nichtraucher innerhalb der Tage. Dabei wurden unterschiedlichen Varianten verwendet: links standard, mittig `position = position_dodge()` und rechts `position = \"fill\"`"
#| label: fig-drei-saeulen

p1 <- gf_bar( ~ day, fill = ~ smoker, data = tips) |> 
  # t r b l
  gf_theme(plot.margin = grid::unit(c(0, 0, 0, 0), "mm"),
           legend.position = "none") + 
  scale_discrete_manual(aesthetics = "fill", values = c(fgcolGray, fgcolFOMGreen))
p2 <- gf_bar( ~ day, fill = ~ smoker, data = tips, position = position_dodge()) |> 
  gf_labs(y = NULL) |> 
  gf_theme(plot.margin = grid::unit(c(0, 0, 0, 0), "mm"),
           legend.position = "none") + 
  scale_discrete_manual(aesthetics = "fill", values = c(fgcolGray, fgcolFOMGreen))
p3 <- gf_bar( ~ day, fill = ~ smoker, data = tips, position = "fill") |> 
  gf_labs(y = NULL) |> 
  gf_theme(plot.margin = grid::unit(c(0, 0, 0, 0), "mm")) + 
  scale_discrete_manual(aesthetics = "fill", values = c(fgcolGray, fgcolFOMGreen))

lay <- rbind(c(1, NA, 2, NA, 3))
grid.arrange(p1, p2, p3, layout_matrix = lay, widths = c(1/58, 0.001, 1/65, 0.001, 1/38))
```

::: {.callout-note .Aufgabe}
## Aufgabe `r quiz <- quiz + 1; paste0(ch, ".", quiz)`

Mit welcher Grafik in @fig-drei-saeulen können Sie am besten erkennen, an welchem Tag ...

a)  die Anzahl der Rauchergruppen am höchsten war?

b)  der Anteil der Rauchergruppen am höchsten war?
:::

Sie sehen, die Positionierung der Aufteilung der Raucher innerhalb der Tage gibt unterschiedliche Informationen. Häufigkeiten erkennen Sie mit `position = position_dodge()` am besten (vgl. die Fläche der Kachel im Mosaikplot) und Anteile mit `position = "fill"` (vgl. die Höhe der Kacheln im Mosaikplot).

::: {.callout-note .Aufgabe}
## Aufgabe `r quiz <- quiz + 1; paste0(ch, ".", quiz)`

Nutzen Sie die Datentabelle SaratogaHouses.[^kapitel-5-2]

a)  Führen Sie eine explorative Datenanalyse der Variable `heating` durch.

b)  Analysieren Sie den Zusammenhang zwischen `heating` und `newConstruction`.
:::

[^kapitel-5-2]: Wie kommen Sie daran? Siehe Abschnitt 2.3 (Erste Schritte in R) in Kapitel 2.

::: {.callout-caution .Lernpfad}
## Lernpfad **Explorative Datenanalyse -- kategorial**

-   Falls Sie bisher wenig mit R gearbeitet haben, können Sie auch die `learnr`-App ausprobieren: <https://fomshinyapps.shinyapps.io/learnR-EDA-kategorial/>.

-   Klären Sie erforderlichenfalls Ihnen noch unbekannte Begriffe eigenständig.

-   Zur Unterstützung gibt es zwei Screencasts: EDA -- Eine kategoriale Variable <https://vimeo.com/398513368> und EDA -- Zwei kategoriale Variablen <https://vimeo.com/398789025>. Die Videos erfordern ein Passwort: *FOMtest*.

-   Lesen Sie zur Vertiefung Kapitel 8.1.1 aus Sebastian Sauer *Moderne Datenanalyse mit R* [@sauer2019]. Das Buch steht über die FOM-Literaturrecherche zur Verfügung.

-   Ergänzend können Sie das Kapitel 4 *Exploring categorical data* aus *Introduction to Modern Statistics* [@mine2021] lesen. Sie können es hier herunterladen: <https://openintro-ims.netlify.app/index.html>
:::

## Analyse metrischer Daten

Im diesem Abschnitt geht es um die Analyse metrischer oder numerischer Daten.

::: {.callout-note .Aufgabe}
## Aufgabe `r quiz <- quiz + 1; paste0(ch, ".", quiz)`

Wissen Sie noch, wie Sie mit R herausfinden konnten, wie unser Datensatz aufgebaut ist? Probieren Sie es aus. Wie viele metrische Variablen gibt es in der Datentabelle tips?
:::

### Histogramm und Verteilungsform {.unnumbered .unlisted}

Als Grafik können auch hier Säulen- und Balkendiagramme verwendet werden. Diese eignen sich insbesondere für metrisch diskrete Daten mit nicht zu vielen Ausprägungen (in der `tips`-Datentabelle z. B. die Anzahl der Personen `size`). Eine weitere wichtige und häufig genutzte Grafik ist das Histogramm :

```{r}
#| fig-cap: "Histogramm der Variable `total_bill`"
#| label: fig-hist-total-bill
gf_histogram( ~ total_bill, data = tips, binwidth = 10, center = 5)
```

@fig-hist-total-bill zeigt das Histogramm der Rechnungsbeträge (`total_bill`). Metrische Daten (insbesondere stetige metrische Daten) werden in Gruppen eingeteilt (`klassifiziert`), z. B. $0 \text{ bis } 10$, $>10$ bis $\leq20$, $\dots$, und die Häufigkeiten als Rechtecke (Säulen) dargestellt. Der Flächeninhalt der Rechtecke entspricht dabei der relativen Häufigkeit der Beobachtungen im Intervall (die sogenannte *Klasse*). Im Unterschied zum Säulendiagramm stehen die einzelnen Säulen jetzt direkt nebeneinander. Das soll zeigen, dass es sich um stetige und nicht um diskrete Daten handelt.

::: {.callout-note .Aufgabe}
## Aufgabe `r quiz <- quiz + 1; paste0(ch, ".", quiz)`

Probieren Sie den Befehl ohne die Eingabe von `binwidth = 10, center = 5` aus. Was ändert sich?
:::

Richtig, jetzt werden viel mehr Säulen gezeigt. `gf_histogram()` wählt automatisch eine bestimmte Breite und nimmt den kleinsten Wert als Startwert. Wenn Sie weniger Säulen (englisch *bins*) haben wollen, ergänzen Sie z. B. `bins = 10` (Anzahl der Säulen). Und wenn Sie ganz bestimmte Gruppen haben wollen, dann nutzen Sie `binwidth` für die Breite der Säule und `center` für den Mittelpunkt einer der Säulen.

::: {.callout-tip .Tipp}
## Tipp

Mehr Informationen zu Histogrammen finden Sie hier: <http://tinlizzie.org/histograms/>.
:::

Ein Histogramm kann dazu genutzt werden, die Form der Verteilung zu bestimmen. @fig-Distributions zeigt typische Formen. Die Verteilungsform ist eine wichtige Eigenschaft von Daten.

```{r}
#| label: fig-Distributions
#| fig-cap: "Verschiedene Verteilungsformen. Bei bimodalen und multimodalen Verteilungen werden nur die ausgeprägten Schwerpunkte gezählt."
#| echo: false
#| fig-width: 4.5
#| fig-asp: 0.7
#| out-width: 10.5cm

source("./misc/Fleishman.R")

n <- 10000

xn <- rnorm(n = n)
nor <- data.frame(Verteilung = "Symmetrisch (Normal)", x = xn)

xls <- rfleish(n = n, skew = -0.65)
xrs <- rfleish(n = n, skew = 0.65)
st <- c(rep("Linksschief", n), rep("Rechtsschief", n))
x <- c(xls, xrs)
schiefe <- data.frame(Verteilung = st, x = x)

xl <- rnorm(0.65*n, mean = -1,sd = 0.5)
xr <- rnorm(0.35*n, mean = 1, sd = 0.5)
xmm <- c(xl,xr)
xmm <- (xmm - mean(xmm))/sd(xmm)
bimod <- data.frame(Verteilung = "Bimodal", x = xmm)

x1 <- rnorm(0.35*n, mean = -1,sd = 0.5)
x2 <- rnorm(0.25*n, mean = 3, sd = 1)
x3 <- rnorm(0.40*n, mean = -5, sd = 0.5)
xmm <- c(x1,x2,x3)
xmm <- (xmm - mean(xmm))/sd(xmm)
multimod <- data.frame(Verteilung = "Multimodal", x = xmm)

xg <- runif(n)
xg <- (xg - mean(xg))/sd(xg)
gleich <- data.frame(Verteilung = "Gleichverteilung", x = xg)

dat <- rbind(nor, schiefe,  bimod, multimod, gleich)
dat <- dat |> mutate(Verteilung = factor(Verteilung, levels = c("Symmetrisch (Normal)", "Linksschief", "Rechtsschief", "Gleichverteilung", "Bimodal", "Multimodal")))

gf_histogram( ~ x | Verteilung, data = dat) |> 
  gf_theme(axis.text = element_blank(), 
           axis.text.y = element_blank(), 
           axis.title.x = element_blank(), 
           axis.title.y = element_blank(), 
           axis.ticks = element_blank(),
           plot.margin = gg0margins)
```

Die Verteilung gibt an, wie häufig bzw. wahrscheinlich bestimmte Werte oder Wertebereiche sind. Bei metrischen Variablen können folgende typische Verteilungsformen unterschieden werden:

-   Bei symmetrischen Verteilungen verteilen sich die Daten symmetrisch um eine zentrale Lage. Häufig sind symmetrische Verteilungen unimodal, haben als nur einen ausgeprägten Schwerpunkt.

-   Schiefe: Bei rechtsschiefen (linkssteilen)Verteilungen sind mehr Beobachtungen im unteren Wertebereich, bei linksschiefen (rechtssteilen) mehr im oberen.

-   Bei einer Gleichverteilung sind die Ausprägungen alle etwa gleich häufig.

-   Bei mehrgipfligen Verteilungen (bimodal, multimodal) gibt es mehr als nur ein ausgeprägtes Zentrum, um das die Werte streuen.

::: {.callout-note .Aufgabe}
## Aufgabe `r quiz <- quiz + 1; paste0(ch, ".", quiz)`

Überlegen Sie sich ein Beispiel für gleichverteilte Daten.
:::

::: {.callout-note .Aufgabe}
## Aufgabe `r quiz <- quiz + 1; paste0(ch, ".", quiz)`

Wie wird wohl das Einkommen in Deutschland verteilt sein?
:::

::: {.callout-note .Aufgabe}
## Aufgabe `r quiz <- quiz + 1; paste0(ch, ".", quiz)`

Betrachten Sie noch einmal @fig-hist-total-bill. Beschreiben Sie die Verteilung von `total_bill`.
:::

Ein Histogramm zeigt die Verteilung von metrischen Daten. Wenn Sie das als stetige Funktion darstellen (Sie verbinden quasi die Mitten der Oberkanten der Rechtecke), erhalten Sie die Dichtefunktion. @fig-Dens zeigt beide Grafen übereinander.[^kapitel-5-3]

[^kapitel-5-3]: Das Histogramm hat als Skalierung auf der $y$-Achse jetzt die Dichte (Häufigkeitsanteil der Klasse geteilt durch Klassenbreite). Die verwendeten Funktionen sind `gf_dhistogram()` und `gf_dens()`.

```{r}
#| echo: false
#| label: fig-Dens
#| fig-cap: "Histogramm (<span style='color: darkgray'>grau</span>) und Dichtefunktion (<span style='color: #00998A'>grün</span>) von `total_bill`"
#| fig-width: 3.5 
#| fig-asp: 1
#| out-width: 7cm

gf_dhistogram( ~ total_bill, data = tips, bins = 9) |> 
  gf_dens(color = fgcolFOMGreen, size = 1, alpha = 1) |> 
  gf_theme(plot.margin = gg0margins)
```

Häufig verwendet wird die Verteilungsfunktion, die das Integral der Dichtfunktion ist. Die **empirische Verteilungsfunktion**[^kapitel-5-4] $F_n(x)$ gibt an, wie hoch der Anteil unter den $n$ Beobachtungen ist, die kleiner oder gleich $x$ sind. @fig-EmpDist zeigt als Beispiel die empirische Verteilungsfunktion der Rechnungshöhe.

[^kapitel-5-4]: Neben der *empirischen* Verteilungsfunktion gibt es auch eine *theoretische* Verteilungsfunktion $F(x)$

$$
F_n(x) = \frac{\text{Anzahl Beobachtungen} \leq x}{x}
$$

Sie sehen, die Verteilungsfunktion gibt auf der $y$-Achse den Anteil der Beobachtungen aus, der kleiner oder gleich dem Wert auf der $x$-Achse ist. Für einen konkreten Wert $x$ können Sie den Wert der Verteilungsfunktion mit `pdata()` ermitteln:

```{r}
pdata( ~ total_bill, q = 10, data = tips)
```

Der Parameter $q$ ist das Quantil (dazu gleich mehr), also der Wert für $x$ in der Formel.

```{r}
#| fig-cap: "Empirische Verteilungsfunktion von `total_bill`"
#| label: fig-EmpDist
#| echo: FALSE
#| fig-width: 3.5
#| fig-asp: 1
#| out-width: 7cm
gf_ecdf( ~ total_bill, data = tips, color = fgcolFOMGreen, size = 1) |> 
  gf_labs(x = TeX("x", italic = TRUE), y = TeX("$F_n(x)$", italic = TRUE)) |> 
  gf_theme(plot.margin = gg0margins)

```

::: {.callout-note .Aufgabe}
## Aufgabe `r quiz <- quiz + 1; paste0(ch, ".", quiz)`

Gerundet hat sich für $F_n(10)$ der Wert $0.07$ ergeben. Welche Aussage stimmt in diesem Zusammenhang?

a)  Der Anteil einer Rechnungshöhe von 10 \$ liegt bei $0.07$.

b)  Der Anteil einer Rechnungshöhe von mindestens 10 \$ liegt bei $0.07$.

c)  Der Anteil einer Rechnungshöhe von höchstens 10 \$ liegt bei $0.07$.
:::

::: {.callout-note .Aufgabe}
## Aufgabe `r quiz <- quiz + 1; paste0(ch, ".", quiz)`

Es gibt keine Verteilungsfunktion für nominalskalierte Daten. Warum nicht?
:::

### Lagemaße {.unnumbered .unlisted}

Zunächst beschäftigen wir uns mit den Lagemaßen einer Verteilung. Lagemaße beschreiben die Lage einer Verteilung, also wo ist der Schwerpunkt, das Minimum, das Maximum usw. Eine Verteilung einer metrischen Variablen können Sie gut mit einem Histogramm darstellen und damit können Sie auch ungefähr abschätzen, wo der Schwerpunkt, das Maximum usw. sind. Lagemaße drücken das al sWert aus und sind somit gewissermaßen Kennzahlen.

Welche Lagemaße gibt es? @tbl-Lagemasse zeigt eine Übersicht.

Ein Lagemaß, das Ihnen bestimmt schon begnetet ist, ist der Durchschnitt oder in der Fachsprache der **arithmetische Mittelwert**. Mit Sicherheit kennen Sie auch **Minimum** und **Maximum**.

Im Folgenden sehen Sie eine Beispielrechnung mit den Daten:

$$20, 18, 24, 40, 24, 22, 21, 23, 20, 28 (n = 10).$$ - Aufsteigend sortiert: 18, 20, 20, 21, 22, 23, 24, 24, 28, 40

-   Minimum $x_{min} = 18$, Maximum $x_{max}= 40$, Modus $x_{mod}= \{20, 24\}$

-   Median[^kapitel-5-5]: $x_{(0.5)} = x_{med} = \frac{20+23}{2} = 22.5$

-   Arithmethischer Mittelwert: $\bar{x}= \frac{1}{10} \cdot (20 + 18 + . . . + 40) = \frac{240}{10} = 24$

-   25%-Quantil[^kapitel-5-6]: $x_{(0.25)}=20$.

[^kapitel-5-5]: Bei gerader Anzahl $n$ wird der Mittelwert der beiden mittleren Werte genommen.

[^kapitel-5-6]: $x_{(0.25)} = x_{\lceil 0.25·n\rceil} = x_3 = 20.$ $\lceil\dots\rceil$ rundet den Wert auf. Es sind aber auch andere Varianten für die Berechnung möglich und üblich. R gibt z. B. $20.25$ aus.

| Lagemaß                                 | Erläuterung                                                                                                                                  |
|:-----------------------------|:-----------------------------------------|
| Minimum, Maximum                        | kleinste bzw. größte Merkmalsausprägung                                                                                                      |
| Modus (Modalwert)                       | häufigste Merkmalsausprägung                                                                                                                 |
| Median (Zentralwert)                    | Merkmalsausprägung, die bei aufsteigend sortierten Daten in der Mitte liegt                                                                  |
| Arithmetischer Mittelwert[^kapitel-5-7] | Summe aller Beobachtungswerte $x_i$ geteilt durch die Anzahl der Beobachtungen $n$: $\bar{x} = \frac{1}{n} \sum_{i=1}{n} x_i$                |
| Quantil                                 | $p$-Quantil: Wert, der von $p$ Prozent der Beobachtungen nicht überschritten wird Quartile Q1: 25%-Quantil, Q2: 50%-Quantil, Q3: 75%-Quantil |

: Übersicht über die Lagemaße {#tbl-Lagemasse}

[^kapitel-5-7]: Englisch: mean. Daneben gibt es noch geometrisches und harmonisches Mittel.

::: {.callout-note .Aufgabe}
## Aufgabe `r quiz <- quiz + 1; paste0(ch, ".", quiz)`

Eine Dozentin unterrichtet vier kleine Kurse mit je 15 Studierenden und einen großen Kurs mit 90 Studierenden.

a)  Wie groß ist der arithmetische Mittelwert der Kursgröße für die Dozenti -
b)  Mit wie vielen Kommiliton:innen sitzt jede(r) Studierende(r) (einschließlich sich selbst) durchschnittlich in einem Kurs?
:::

::: {.callout-tip .Tipp}
## Tipp

Die Ergebnisse werden sich unterscheiden! Schauen Sie nicht gleich in der Lösung nach. Selbst die Lösung zu suchen ist Ihr Schlüssel zum Lernerfolg!
:::

Im Alltag etwas weniger gebräuchlich ist der Median oder Zentralwert. Um ihn herzuleiten, brauchen wir wieder die Verteilungsfunktion (in @fig-Median sehen Sie das Beispiel aus dem vorherigen Abschnitt).

```{r}
#| echo: false
#| fig-width: 3.5
#| fig-asp: 1
#| out-width: 7cm
#| fig-cap: "Empirische Verteilungsfunktion von `total_bill`, eingezeichnet ist der Median, das 50%-Quantil"
#| label: fig-Median
xqz <- median( ~ total_bill, data = tips)
# wegen gf_line mit anderen Daten muss die Variable direkt aufgerufen werden
gf_ecdf( ~ tips$total_bill, color = fgcolFOMGreen, size = 1) |> 
  gf_labs(x = TeX("x", italic = TRUE), y = TeX("$F_n(x)$", italic = TRUE)) |> 
  gf_theme(plot.margin = gg0margins) |> 
  gf_line( c(0.5, 0.5) ~ c(0, xqz), arrow = arrow(length = unit(0.7, "char")),
           size = 1, color = fgcolBlue) |> 
  gf_line( c(0.5, 0) ~ c(xqz, xqz), arrow = arrow(length = unit(0.7, "char")),
           size = 1, color = fgcolBlue)
```

Der **Median** ist in der Mitte der aufsteigend sortierten Daten. An der Verteilungsfunktion (@fig-Median) können Sie ihn ablesen: Sie gehen von der 0.5 auf der $y$-Achse und lesen den Wert auf der $x$-Achse ab: ungefähr 18 \$. Daher haben 50% der Rechnungen einen Wert von 18 \$ oder weniger, der Rest ist höher.

::: {.callout-note .Aufgabe}
## Aufgabe `r quiz <- quiz + 1; paste0(ch, ".", quiz)`

Berechnen Sie in R den Mittelwert und den Median der Rechnungshöhe. Die Funktionen sind `mean(~ x, data = my.data)` und `median(...)`. Sie sehen, der Mittelwert ist größer als der Median. Das ist bei rechtsschiefen Verteilungen häufig so (erinnern Sie sich an das Histogramm von `total_bill`?). Bei rechtsschiefen Verteilungen sind einige Werte weit entfernt im Bereich hoher Werte, das zieht den Mittelwert nach rechts. Das arithmetische Mittel ist also empfindlich gegenüber Ausreißern. Der Median hingegen ist robust.

**Modellierung I** In der quantitativen Datenanalyse wollen wir häufig modellieren. Das einfachste Modell ist der arithmetische Mittelwert (Modellierung ohne unabhängige Variable, hier z. B. `total_bill ~ 1`):

$$
\begin{aligned}
  \text{Daten} &= \text{Modell} + \text{Rest}, \\
  x_i &= \bar x + e_i, \\
  x_i &= \bar x + (x_i - \bar x).
\end{aligned}
$$

Der Rest $e_i$ ist dann für jede Beobachtung die Abweichung[^kapitel-5-8] zum Mittelwert.

[^kapitel-5-8]:  Zur Einschätzung, ob die Abweichung groß oder klein ist, wird die Streuung (siehe Abschnitt **Streumaße**) der Daten herangezogen.

```{r}
#| echo: false
#| include: false
yq = mean( ~ total_bill, data = tips)
f1txt <- sprintf("%.2f", sum((tips$total_bill - yq )^2))
```

Im Allgemeinen suchen wir (mathematisch gesprochen) nach einer Funktion $f(x)$, die eine Beziehung zwischen den Daten $x$ und $y$ bis auf einen Fehlerterm $\epsilon$ darstellt:

$$
y = f(x) + \epsilon
$$

Unsere aktuelle Schätzung für $f$ ist der Mittelwert der $y_i$-Wert und lautet daher: 

$$
\hat f(x) = `r yq`
$$ 

Damit können wir auch für jedes $x$ eine Schätzung für $y$ abgeben: $\hat y = \hat f(x) = `r yq`$. Für alle bekannten Datenpunktpaare $(x_i, y_i)$ können wir jeweils auch den Rest als Fehlerterm bestimmen: $e_i = y_i -\hat y_i = y_i - `r yq`$.

Der gesamte Rest kann daher über die Summe der quadrierten Abweichungen der einzelnen Beobachtungen zum Mittelwert dargestellt werden:

$$
  \sum_{i=1}^n e_i^2 = \sum_{i=1}^n (x_i - \bar x)^2.
$$

Hier ergibt sich als Quadratesumme: $\sum e_i^2 = `r f1txt`$.

::: {.callout-note .Aufgabe}
## Aufgabe `r quiz <- quiz + 1; paste0(ch, ".", quiz)`

Warum wird bei der Aufsummierung quadriert?
:::

Der Median ist das 50%-Quantil einer Verteilung. Allgemein ist das **p-Quantil** der Wert, bei dem $p\,\%$ (in der Verteilungsfunktion in @fig-Median der Wert auf der $y$-Achse) der Werte kleiner oder gleich dem p%-Quantil (in @fig-Median der Wert auf der $x$-Achse) sind. 
Das Minimum kann auch als 0%-Quantil und das Maximum als 100%-Quantil betrachtet werden.

::: {.callout-tip .Hinweis}
## Hinweis

Wichtige Quantile sind das 25%-Quantil oder **1. Quartil**, das 50%-Quantil oder **2. Quartil** (bzw. *Median*) und das 75%-Quantil oder **3. Quartil**. 
Der Median teilt eine Reihe von Daten in zwei Teile, die Quartile entsprechend in vier Teile.
:::

Um Quantile zu bestimmen, können wir in R die Funktion `qdata()` verwenden. Als Beispiel sei hier das 10%-Quantil der Rechnungshöhe gezeigt:

```{r}
#| echo: true
#| eval: true
qdata( ~ total_bill, p = 0.1, data = tips)
```

10% der Werte der Rechnungshöhe sind kleiner oder gleich `r qdata( ~ total_bill, p = 0.1, data = tips)` \$. Umgekehrt heißt das, $1-10=90$ % sind größer.

::: {.callout-note .Aufgabe}
## Aufgabe `r quiz <- quiz + 1; paste0(ch, ".", quiz)`

Bestimmen Sie die Quartile der Rechnungshöhe. Mehrere Werte für die Angabe bei `p =` können Sie mit `c(#1, #2, ...)`[^kapitel-5-9] kombinieren.
:::

[^kapitel-5-9]: `c()` steht für englisch *concatenate* -- verketten.

### Streumaße {.unnumbered .unlisted}
